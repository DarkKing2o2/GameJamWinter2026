[gd_resource type="BehaviorTree" format=3 uid="uid://g2wjqmkryvhc"]

[sub_resource type="BlackboardPlan" id="BlackboardPlan_jajy7"]
var/target/name = &"target"
var/target/type = 24
var/target/hint = 17
var/target/hint_string = ""
var/collisionVector/name = &"collisionVector"
var/collisionVector/type = 5
var/collisionVector/value = Vector2(0, 0)
var/collisionVector/hint = 0
var/collisionVector/hint_string = ""
resource_local_to_scene = true

[sub_resource type="GDScript" id="GDScript_cua5h"]
script/source = "## Tool keyword added for _generate_name()
@tool

extends BTCondition
## Checks if agent is in spotting range of target, returning [code]SUCCESS[/code]. [br]
## Returns [code]FAILURE[/code] if [agent] is not within [member target] range.
## Uses blackboard var target which comes from agents internal target var.

## Store a local reference to the blackboard vars to save resources.
var _target = \"target\"
var _spotRange = \"spotRange\"
var target
var spotRange

# Display a customized name (requires @tool).
func _generate_name() -> String:
	# Should print \"Is <TargetName> in range?\"
	return \"Is target in spotting range?\"

func _setup() -> void:
	self.target = blackboard.get_var(self._target)
	self.spotRange = blackboard.get_var(self._spotRange)


## Called each time this task is ticked (aka executed).
func _tick(_delta: float) -> Status:
	# Update target var just in case.
	target = blackboard.get_var(self._target)
	# Check if it exists. If not, we can switch routine to something else vs
	#	outright crashing.
	if not is_instance_valid(target):
		breakpoint
		return FAILURE
	# Calculate the distance from us to the target.
	# TODO: refactor to call agents spot_range var when we create it.
	var distance : float = target.global_position.x - agent.global_position.x
	# If it's less than some factor x, return success, else failure
	if distance < spotRange :
		return SUCCESS
	else : return FAILURE
"

[sub_resource type="BTCondition" id="BTCondition_wrjqh"]
script = SubResource("GDScript_cua5h")

[sub_resource type="BBNode" id="BBNode_71yjm"]
saved_value = NodePath("AnimationPlayer")
resource_name = "AnimationPlayer"

[sub_resource type="BTPlayAnimation" id="BTPlayAnimation_86lse"]
animation_player = SubResource("BBNode_71yjm")
animation_name = &"idle"

[sub_resource type="GDScript" id="GDScript_f85c6"]
script/source = "## Tool keyword added for _generate_name()
@tool


extends BTAction
## Move towards the target while not at desired postition or script is allowed to continue.  [br]
## Returns [code]RUNNING[/code] while moving towards the target but not yet at the desired position. [br]
## Returns [code]SUCCESS[/code] when at the desired position relative to the target. [br]
## Returns [code]FAILURE[/code] if we cannot reach the target for some reason.[br]

## Store a local reference to the blackboard vars to save resources.
var _target = \"target\"
var _spotRange = \"spotRange\"
var _attackRange = \"attackRange\"
var target
var spotRange
var attackRange

func _setup() -> void:
	self.target = blackboard.get_var(self._target)
	self.spotRange = blackboard.get_var(self._spotRange)
	self.attackRange = blackboard.get_var(self._attackRange)



# Display a customized name (requires @tool).
func _generate_name() -> String:
	# Should print \"Is <TargetName> in range?\"
	return \"Purse target until in attack range.\"


# Called each time this task is ticked (aka executed).
func _tick(_delta: float) -> Status:
	target = blackboard.get_var(self._target)
	if not is_instance_valid(target):
		return FAILURE

	# If distance to target is less than the agents attack range, we've successfully
	#	pursed the target.
	var desired_pos: Vector2 = target.global_position
	if agent.global_position.distance_to(desired_pos) < attackRange: return SUCCESS

	#print_debug()
	#print(\"True dist to player: \", agent.global_position.distance_to(desired_pos) )
	# Get the vector from agent to target = target-> minus agent->
	var directionToMoveIn : Vector2 = ( self.target.global_position - self.agent.global_position).normalized()
	agent.move(directionToMoveIn )
	return RUNNING
"

[sub_resource type="BTAction" id="BTAction_md1nl"]
script = SubResource("GDScript_f85c6")

[sub_resource type="BTTimeLimit" id="BTTimeLimit_f85c6"]
time_limit = 2.0
children = [SubResource("BTAction_md1nl")]

[sub_resource type="BTSequence" id="BTSequence_jajy7"]
custom_name = "Target_In_Spot_Range"
children = [SubResource("BTCondition_wrjqh"), SubResource("BTPlayAnimation_86lse"), SubResource("BTTimeLimit_f85c6")]

[sub_resource type="GDScript" id="GDScript_wrjqh"]
script/source = "## Tool keyword added for _generate_name()
@tool

extends BTCondition
## Checks if agent is in attack range of target, returning [code]SUCCESS[/code]. [br]
## Returns [code]FAILURE[/code] if [agent] is not within [member target] range.
## Uses blackboard var target which comes from agents internal target var.

## Store a local reference to the blackboard vars to save resources.
var _target = \"target\"
var _attackRange = \"attackRange\"
var target
var attackRange

# Display a customized name (requires @tool).
func _generate_name() -> String:
	# Should print \"Is <TargetName> in range?\"
	return \"Is target within attacking range?\"

func _setup() -> void:
	self.target = blackboard.get_var(self._target)
	self.attackRange = blackboard.get_var(self._attackRange)


## Called each time this task is ticked (aka executed).
func _tick(_delta: float) -> Status:
	# Update target var just in case.
	target = blackboard.get_var(self._target)
	# Check if it exists. If not, we can switch routine to something else vs
	#	outright crashing.
	if not is_instance_valid(target):
		breakpoint
		return FAILURE

	# Since all is valid, check that we are within the attack range
	#	distance to the target.
	# Calculate the distance from us to the target.
	# TODO: refactor to call agents spot_range var when we create it.
	var distance : float = target.global_position.x - agent.global_position.x
	if distance < attackRange :
		return SUCCESS
	else : return FAILURE
"

[sub_resource type="BTCondition" id="BTCondition_batpb"]
script = SubResource("GDScript_wrjqh")

[sub_resource type="BBNode" id="BBNode_batpb"]
saved_value = NodePath("AnimationPlayer")
resource_name = "AnimationPlayer"

[sub_resource type="BTPlayAnimation" id="BTPlayAnimation_7pbyg"]
animation_player = SubResource("BBNode_batpb")
animation_name = &"attack"

[sub_resource type="GDScript" id="GDScript_md1nl"]
script/source = "## Tool keyword added for _generate_name()
@tool

extends BTAction
## Attacks player, returning [code]SUCCESS[/code]. If player was hit. [br]
## Returns [code]FAILURE[/code] if [agent] if player was not hit.
## Uses blackboard var target which comes from agents internal target var.

## Store a local reference to the blackboard vars to save resources.
var _target = \"target\"
var _attack = \"attack\"
var target
var attack

# Display a customized name (requires @tool).
func _generate_name() -> String:
	# Should print \"Is <TargetName> in range?\"
	return \"Attack target with melee attack\"

func _setup() -> void:
	self.target = blackboard.get_var(self._target)
	self.attack = blackboard.get_var(self._attack)


## Called each time this task is ticked (aka executed).
func _tick(_delta: float) -> Status:
	# Update target var just in case.
	target = blackboard.get_var(self._target)
	# Check if it exists. If not, we can switch routine to something else vs
	#	outright crashing.
	if not is_instance_valid(target):
		breakpoint
		return FAILURE

	# Do the attack
	self.attack.do_Attack()
	return SUCCESS
"

[sub_resource type="BTAction" id="BTAction_7pbyg"]
script = SubResource("GDScript_md1nl")

[sub_resource type="BTCooldown" id="BTCooldown_7pbyg"]
duration = 2.0
children = [SubResource("BTAction_7pbyg")]

[sub_resource type="BBNode" id="BBNode_7pbyg"]
saved_value = NodePath("AnimationPlayer")
resource_name = "AnimationPlayer"

[sub_resource type="BTAwaitAnimation" id="BTAwaitAnimation_71yjm"]
animation_player = SubResource("BBNode_7pbyg")
animation_name = &"attack"

[sub_resource type="BTWait" id="BTWait_batpb"]
duration = 0.2

[sub_resource type="BTSequence" id="BTSequence_batpb"]
custom_name = "Target_In_Attack_Range"
children = [SubResource("BTCondition_batpb"), SubResource("BTPlayAnimation_7pbyg"), SubResource("BTCooldown_7pbyg"), SubResource("BTAwaitAnimation_71yjm"), SubResource("BTWait_batpb")]

[sub_resource type="BBNode" id="BBNode_jajy7"]
saved_value = NodePath("AnimationPlayer")
resource_name = "AnimationPlayer"

[sub_resource type="BTPlayAnimation" id="BTPlayAnimation_a2yvw"]
await_completion = 1.0
animation_player = SubResource("BBNode_jajy7")
animation_name = &"idle"

[sub_resource type="BTSequence" id="BTSequence_wb8dk"]
custom_name = "Idle"
children = [SubResource("BTPlayAnimation_a2yvw")]

[sub_resource type="BTSequence" id="BTSequence_7pbyg"]
custom_name = "Logic_Root : Seqentially calls children so long as they return Success"
children = [SubResource("BTSequence_jajy7"), SubResource("BTSequence_batpb"), SubResource("BTSequence_wb8dk")]

[resource]
description = "Behaviour tree for the flying monster. 
Requires a reference to the target to be added to the blackboard before activating the behaviour tree."
blackboard_plan = SubResource("BlackboardPlan_jajy7")
root_task = SubResource("BTSequence_7pbyg")
